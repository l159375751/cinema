<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Mini Cinema</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="cinema:collection_source" content="https://en.btdig.com/c9c47e7b12586a59d83e3e519570835625d44b3e/werner-herzog">
  <meta name="cinema:version" content="POC0.2">
  <style>
    :root {
      color-scheme: dark;
      --bg: #050608;
      --bg-alt: #111219;
      --accent: #e0c680;
      --accent-soft: rgba(224, 198, 128, 0.14);
      --text: #f3f3f5;
      --muted: #a3a3b5;
      --border: #252637;
      --radius: 10px;
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "SF Pro Text",
        "Segoe UI", sans-serif;
      background: var(--bg);
      color: var(--text);
      min-height: 100vh;
      display: flex;
      flex-direction: column;
    }

    .app {
      max-width: 1120px;
      margin: 0 auto;
      padding: 16px 16px 24px;
      display: flex;
      flex-direction: column;
      gap: 16px;
    }

    header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 8px;
    }

    .title {
      font-size: 20px;
      font-weight: 600;
      letter-spacing: 0.03em;
      text-transform: uppercase;
      display: inline-flex;
      align-items: center;
      gap: 8px;
    }

    .title-mark {
      width: 16px;
      height: 16px;
      border-radius: 999px;
      background: #e2e2ea;
      box-shadow: none;
    }

    .subtitle {
      font-size: 13px;
      color: var(--muted);
    }

    .layout {
      display: flex;
      flex-direction: column;
      gap: 16px;
      align-items: stretch;
    }

    .panel {
      background: var(--bg-alt);
      border-radius: var(--radius);
      border: 1px solid var(--border);
      box-shadow: none;
      padding: 12px 12px 14px;
      backdrop-filter: none;
    }

    .panel-body {
      margin-top: 4px;
    }

    .panel-collapsed .panel-body {
      display: none;
    }

    .player-panel {
      padding: 10px;
    }

    .player-shell {
      position: relative;
      border-radius: calc(var(--radius) - 2px);
      overflow: hidden;
      background: #151621;
      border: 1px solid rgba(255, 255, 255, 0.06);
      box-shadow: none;
      aspect-ratio: 16 / 9;
    }

    video {
      width: 100%;
      height: 100%;
      display: block;
      background: #050608;
    }

    .player-overlay {
      position: absolute;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      pointer-events: none;
    }

    .player-overlay-badge {
      padding: 6px 12px;
      border-radius: 999px;
      background: rgba(0, 0, 0, 0.6);
      border: 1px solid rgba(255, 255, 255, 0.1);
      font-size: 11px;
      letter-spacing: 0.06em;
      text-transform: none;
      color: var(--muted);
    }

    .panel-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 8px;
      gap: 8px;
    }

    .panel-title {
      font-size: 13px;
      text-transform: none;
      letter-spacing: 0.04em;
      color: var(--muted);
    }

    .chip {
      font-size: 11px;
      padding: 3px 8px;
      border-radius: 999px;
      background: var(--accent-soft);
      color: var(--accent);
      border: 1px solid rgba(224, 198, 128, 0.35);
      text-transform: none;
      letter-spacing: 0.06em;
    }

    .library-list {
      list-style: none;
      margin: 0;
      padding: 0;
      display: flex;
      flex-direction: column;
      gap: 6px;
      max-height: 340px;
      overflow: auto;
    }

    .movie {
      display: flex;
      gap: 8px;
      padding: 7px 8px;
      border-radius: 8px;
      border: 1px solid transparent;
      background: transparent;
      cursor: pointer;
      transition: background 120ms ease, border-color 120ms ease;
      text-align: left;
      color: inherit;
    }

    .movie:hover {
      background: rgba(255, 255, 255, 0.03);
      border-color: rgba(255, 255, 255, 0.04);
    }

    .movie.is-active {
      background: rgba(224, 198, 128, 0.12);
      border-color: rgba(224, 198, 128, 0.65);
    }

    .movie-thumb {
      width: 40px;
      height: 40px;
      border-radius: 8px;
      flex-shrink: 0;
      background: #1b1b24;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 10px;
      font-weight: 600;
      text-transform: uppercase;
      color: #1b0c11;
    }

    .movie-main {
      flex: 1;
      min-width: 0;
      display: flex;
      flex-direction: column;
      gap: 2px;
    }

    .movie-header-row {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
    }

    .movie-title {
      font-size: 13px;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .movie-meta {
      font-size: 11px;
      color: var(--muted);
      display: flex;
      justify-content: space-between;
      gap: 8px;
    }

    .movie-meta-right {
      display: flex;
      flex-direction: column;
      align-items: flex-end;
      gap: 2px;
    }

    .movie-tags {
      display: inline-flex;
      gap: 4px;
      flex-wrap: wrap;
    }

    .movie-tag {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      padding: 1px 6px;
      border-radius: 999px;
      border: 1px solid rgba(255, 255, 255, 0.12);
      font-size: 10px;
      text-transform: uppercase;
      letter-spacing: 0.12em;
      color: var(--muted);
    }

    .movie-meta-size {
      font-variant-numeric: tabular-nums;
    }

    .movie-download-button {
      padding: 2px 8px;
      border-radius: 999px;
      border: 1px solid var(--border);
      background: rgba(0, 0, 0, 0.4);
      color: var(--muted);
      font-size: 10px;
      cursor: pointer;
    }

    .movie-download-button:hover {
      border-color: rgba(224, 198, 128, 0.5);
      background: rgba(224, 198, 128, 0.06);
      color: var(--accent);
    }

    .movie-download-button.is-arming {
      background: var(--accent-soft);
      border-color: rgba(224, 198, 128, 0.85);
      color: var(--accent);
    }

    .movie-download-button.is-progress {
      background: #285b3a;
      border-color: #6fb17a;
      color: #d4f8dd;
    }

    .movie-download-button.is-done {
      background: #163022;
      border-color: #5a8f63;
      color: #c6f0cf;
    }

    .badge-soft {
      padding: 2px 6px;
      border-radius: 999px;
      background: rgba(255, 255, 255, 0.03);
      border: 1px solid rgba(255, 255, 255, 0.06);
      font-size: 11px;
      color: var(--muted);
    }

    .status-panel {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
      gap: 8px 16px;
      align-items: flex-start;
      margin-top: 4px;
    }

    .status-item {
      display: flex;
      flex-direction: column;
      gap: 2px;
      min-width: 0;
    }

    .status-label {
      font-size: 11px;
      color: var(--muted);
      text-transform: none;
      letter-spacing: 0.06em;
    }

    .status-value {
      font-size: 13px;
      font-variant-numeric: tabular-nums;
      margin-top: 3px;
    }

    .status-value-strong {
      color: var(--accent);
    }

    .status-caption {
      margin-top: 8px;
      font-size: 11px;
      color: var(--muted);
      display: flex;
      justify-content: space-between;
      gap: 8px;
    }

    .dot {
      width: 8px;
      height: 8px;
      border-radius: 999px;
      background: #5a8f63;
      box-shadow: none;
      margin-right: 4px;
    }

    .status-caption-left {
      display: inline-flex;
      align-items: center;
      gap: 4px;
    }

    .status-caption-right {
      font-variant-numeric: tabular-nums;
    }

    .infohash {
      margin-top: 6px;
      font-size: 11px;
      color: var(--muted);
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas,
        "Liberation Mono", "Courier New", monospace;
      word-break: break-all;
    }

    .player-meta {
      margin-top: 8px;
      font-size: 12px;
      color: var(--muted);
      display: flex;
      flex-direction: column;
      gap: 2px;
    }

    .player-meta-line {
      display: flex;
      gap: 4px;
      align-items: baseline;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .player-meta-label {
      font-weight: 500;
      color: var(--muted);
    }

    .player-meta-value {
      flex: 1;
      min-width: 0;
      color: var(--text);
    }

    #player-meta-title {
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas,
        "Liberation Mono", "Courier New", monospace;
    }

    .client-row {
      margin-top: 4px;
      display: flex;
      flex-direction: column;
      gap: 4px;
    }

    .client-row-inline {
      flex-direction: row;
      align-items: center;
      gap: 8px;
    }

    .library-status {
      font-size: 11px;
      color: var(--muted);
      display: inline-flex;
      align-items: center;
      gap: 4px;
    }

    .library-spinner {
      width: 10px;
      height: 10px;
      border-radius: 999px;
      border: 2px solid rgba(255, 255, 255, 0.16);
      border-top-color: var(--accent);
      box-sizing: border-box;
      animation: library-spin 0.7s linear infinite;
      display: none;
    }

    .library-spinner.is-active {
      display: inline-block;
    }

    @keyframes library-spin {
      to {
        transform: rotate(360deg);
      }
    }

    .client-label {
      font-size: 11px;
      color: var(--muted);
    }

    .client-input {
      width: 100%;
      padding: 6px 8px;
      border-radius: 6px;
      border: 1px solid var(--border);
      background: #090a10;
      color: var(--text);
      font-size: 12px;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas,
        "Liberation Mono", "Courier New", monospace;
    }

    .client-input::placeholder {
      color: rgba(163, 163, 181, 0.7);
    }

    .client-actions {
      margin-top: 6px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
      flex-wrap: wrap;
    }

    .client-button {
      padding: 5px 10px;
      border-radius: 999px;
      border: 1px solid rgba(224, 198, 128, 0.4);
      background: transparent;
      color: var(--accent);
      font-size: 12px;
      cursor: pointer;
    }

    .client-button:hover {
      border-color: rgba(224, 198, 128, 0.7);
      background: rgba(224, 198, 128, 0.08);
    }

    .client-note {
      font-size: 11px;
      color: var(--muted);
    }

    .client-presets {
      margin: 6px 0 0;
      padding: 0;
      list-style: none;
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
    }

    .client-preset {
      padding: 3px 8px;
      border-radius: 999px;
      border: 1px solid var(--border);
      background: transparent;
      color: var(--muted);
      font-size: 11px;
      cursor: pointer;
    }

    .client-preset:hover {
      border-color: rgba(224, 198, 128, 0.6);
      color: var(--accent);
    }

    .nostr-block {
      margin-top: 4px;
      padding: 6px 8px;
      border-radius: 6px;
      border: 1px solid var(--border);
      background: #090a10;
      color: var(--muted);
      font-size: 11px;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas,
        "Liberation Mono", "Courier New", monospace;
      min-height: 180px;
      max-height: 600px;
      overflow: auto;
      white-space: pre-wrap;
      resize: vertical;
    }

    footer {
      margin-top: 4px;
      font-size: 11px;
      color: var(--muted);
      display: flex;
      justify-content: space-between;
      gap: 8px;
      padding: 0 2px 2px;
    }

    footer a {
      color: var(--accent);
      text-decoration: none;
    }

    footer a:hover {
      text-decoration: underline;
    }

    @media (max-width: 860px) {
      .layout {
        grid-template-columns: minmax(0, 1fr);
      }

      .status-panel {
        grid-template-columns: repeat(2, minmax(0, 1fr));
      }
    }

    @media (max-width: 520px) {
      .status-panel {
        grid-template-columns: minmax(0, 1fr);
      }

      .panel {
        padding: 10px 10px 12px;
      }

      .player-panel {
        padding: 8px;
      }
    }
  </style>
</head>
<body>
  <div class="app">
    <header>
      <div>
        <div class="title">
          <span class="title-mark"></span>
          Mini Cinema
        </div>
        <div class="subtitle">POC0.2 · WebTorrent cinema mini p2p archive</div>
      </div>
      <span class="chip">POC0.2</span>
    </header>

    <main class="layout">
      <section class="panel player-panel">
        <div class="player-shell">
          <video id="player" controls preload="metadata"></video>
          <div class="player-overlay">
            <div class="player-overlay-badge" id="player-overlay-badge">
              Select a mock title to start
            </div>
          </div>
        </div>
        <div class="player-meta">
          <div class="player-meta-line">
            <span class="player-meta-label">Title:</span>
            <span class="player-meta-value" id="player-meta-title">No film selected</span>
          </div>
          <div class="player-meta-line">
            <span class="player-meta-label">Media:</span>
            <span class="player-meta-value" id="player-meta-file">No media file loaded</span>
          </div>
        </div>
      </section>

      <aside class="panel">
        <div class="panel-header">
          <div class="panel-title">Library</div>
          <span class="badge-soft" id="library-count">0 items</span>
        </div>
        <div class="client-row client-row-inline">
          <div class="client-label">Collection:</div>
          <select class="input" id="collection-mode">
            <option value="blender" selected>Blender films</option>
            <option value="herzog">Werner Herzog collection</option>
          </select>
        </div>
        <div class="client-row client-row-inline">
          <span class="library-status">
            <span class="library-spinner" id="library-spinner"></span>
            <span id="library-status-text">Library idle</span>
          </span>
        </div>
        <ul class="library-list" id="movie-list"></ul>
      </aside>
    </main>

    <section class="panel">
      <div class="panel-header">
        <div class="panel-title">Transfer Channel</div>
        <span class="badge-soft" id="status-label">Idle</span>
      </div>
      <div class="status-panel">
        <div class="status-item">
          <div class="status-label">Now Playing</div>
          <div class="status-value status-value-strong" id="status-title">
            Nothing queued
          </div>
        </div>
        <div class="status-item">
          <div class="status-label">Progress</div>
          <div class="status-value" id="status-progress">0%</div>
        </div>
        <div class="status-item">
          <div class="status-label">Peers</div>
          <div class="status-value" id="status-peers">0</div>
        </div>
        <div class="status-item">
          <div class="status-label">Down / Up</div>
          <div class="status-value" id="status-speed">0 kB/s · 0 kB/s</div>
        </div>
        <div class="status-item">
          <div class="status-label">Total size</div>
          <div class="status-value" id="status-total-size">unknown</div>
        </div>
      </div>
      <div class="status-caption">
        <div class="status-caption-left">
          <span class="dot" id="status-dot"></span>
          WebTorrent client in browser
        </div>
        <div class="status-caption-right" id="status-extra">Library idle; no active swarm</div>
      </div>
      <div class="infohash" id="active-infohash">
        Infohash: —
      </div>
      <div class="client-row">
        <div class="client-label">Cinema bag (all infohashes)</div>
        <pre class="nostr-block" id="whda-infohashes">// Cinema bag not loaded yet.</pre>
      </div>
      <div class="client-row">
        <span class="client-note" id="nostr-status">
          Nostr presets: idle
        </span>
        <span class="client-note" id="metadata-scan-status">
          Metadata scan: idle
        </span>
      </div>
      <div class="client-row">
        <div class="client-label">Metadata log</div>
        <div class="client-note" id="metadata-log"></div>
      </div>
    </section>

    <section class="panel panel-collapsed" id="cinema-nostr-panel">
      <div class="panel-header">
        <div class="panel-title">Cinema Nostr draft</div>
        <button class="client-button" id="cinema-nostr-toggle" type="button">Show</button>
      </div>
      <div class="panel-body">
        <div class="client-row">
          <div class="client-label">
            Example content payload for kind 30317 / d=WHDA
          </div>
          <pre class="nostr-block" id="nostr-whda" contenteditable="true" spellcheck="false">// Loading WHDA draft…</pre>
        </div>
      <div class="client-row">
        <div class="client-label">
          Remote cinema notes (last 10, by d/id)
          <span class="library-spinner" id="nostr-remote-spinner"></span>
        </div>
          <select class="input" id="nostr-whda-remote-select">
            <option value="__reload__">Load from relay…</option>
          </select>
        </div>
        <div class="client-row">
          <div class="client-label">d tag for this cinema note</div>
          <input
            class="client-input"
            id="nostr-whda-d"
            type="text"
            value="WHDA"
          >
        </div>
        <div class="client-row">
          <span class="client-note" id="nostr-key-label">
            Local Nostr key: not generated
          </span>
        </div>
        <div class="client-actions">
          <button class="client-button" id="nostr-whda-example">Generate example WHDA</button>
          <button class="client-button" id="nostr-whda-apply">Apply draft locally</button>
          <button class="client-button" id="nostr-whda-reload">Reload from relay</button>
          <button class="client-button" id="nostr-whda-sync">Sync cinema note to relay</button>
          <span class="client-note">Draft is local-only; sync uses local key/nostr-tools when available (relays may still reject).</span>
        </div>
        <div class="client-row">
          <div class="client-label">EVENT frame (last WHDA EVENT sent to relay)</div>
          <pre class="nostr-block" id="nostr-event-frame">// EVENT frame will appear here when you sync.</pre>
        </div>
      </div>
    </section>

    <section class="panel">
      <div class="panel-header">
        <div class="panel-title">About this POC</div>
      </div>
      <p style="margin: 0; font-size: 12px; color: var(--muted);">
        POC0 is a single-page, browser-based WebTorrent viewer for the “Werner Herzog Collection”
        infohash. It exposes the collection hash and a simple client so future iterations can
        plug in a Nostr-backed bibliography instead of the built-in magnet.
      </p>
    </section>

    <footer>
      <span>Open this file directly or via any static server.</span>
      <span>Collection metadata source: <a href="https://en.btdig.com/c9c47e7b12586a59d83e3e519570835625d44b3e/werner-herzog">Werner Herzog torrent</a>.</span>
    </footer>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/webtorrent@latest/webtorrent.min.js"></script>
  <script src="https://unpkg.com/nostr-tools@1.19.0/lib/nostr.bundle.js"></script>
  <script>
    const COLLECTION_INFOHASH = "c9c47e7b12586a59d83e3e519570835625d44b3e";
    const COLLECTION_LABEL = "Werner Herzog Collection";
    const NOSTR_RELAY = "wss://relay.0x6d.net";
    const NOSTR_PRESETS_KIND = 30317;
    const NOSTR_PRESETS_D = "herzog-docs-presets";
    const NOSTR_WHDA_D = "WHDA";
    const MAGNET_TRACKERS =
      "&tr=wss%3A%2F%2Ftracker.openwebtorrent.com" +
      "&tr=wss%3A%2F%2Ftracker.webtorrent.dev" +
      "&tr=wss%3A%2F%2Ftracker.btorrent.xyz" +
      "&tr=wss%3A%2F%2Ftracker.0x6d.net";

    let whdaStatus = {};
    let filmBag = [];
    let collectionMode = "blender"; // "blender" or "herzog"

    const EXAMPLE_WHDA_ITEMS = [
      {
        hash: "403484f62da4fbc835c60736cad841e4cc1a3641",
        title: "a1-charge – Blender single file",
      },
      {
        hash: "460b0b5d942af2de6e3d69333c782f391fcc1ee0",
        title: "Charge – Blender Open Movie",
      },
      {
        hash: "08ada5a7a6183aae1e09d831df6748d566095a10",
        title: "Sintel – Blender Open Movie (2010)",
      },
      {
        hash: "c9e15763f722f23e98a29decdfae341b98d53056",
        title: "Cosmos Laundromat – First Cycle (2015)",
      },
      {
        hash: "dd8255ecdc7ca55fb0bbf81323d87062db1f6d1c",
        title: "Big Buck Bunny (2008)",
      },
      {
        hash: "209c8226b299b308beaf2b9cd3fb49212dbd13ec",
        title: "Tears of Steel (2012)",
      },
    ];
    const COLLECTION_MAGNET =
      "magnet:?xt=urn:btih:" +
      COLLECTION_INFOHASH +
      "&dn=" +
      encodeURIComponent(COLLECTION_LABEL) +
      MAGNET_TRACKERS;
    const DEFAULT_FILE_MATCH = "grizzly man";

    function formatSize(bytes) {
      if (!Number.isFinite(bytes) || bytes <= 0) return "unknown";
      const units = ["B", "kB", "MB", "GB", "TB"];
      let value = bytes;
      let unitIndex = 0;
      while (value >= 1024 && unitIndex < units.length - 1) {
        value /= 1024;
        unitIndex += 1;
      }
      return value.toFixed(value >= 100 || unitIndex === 0 ? 0 : 1) + " " + units[unitIndex];
    }

    function refreshWhdaInfohashes() {
      const whdaInfohashesEl = document.getElementById("whda-infohashes");
      if (!whdaInfohashesEl) return;
      if (!Array.isArray(filmBag) || !filmBag.length) {
        whdaInfohashesEl.textContent = "// WHDA bag empty.";
        return;
      }
      const lines = filmBag.map((item, index) => {
        const hash = (item.hash || "").trim();
        const fullHash = hash || "no-hash";
        const title = item.title || hash || "Untitled";
        const key = hash.toLowerCase();
        const status = whdaStatus[key] || {};
        const peers = status.peers != null ? status.peers : 0;
        const progress =
          status.progress != null
            ? status.progress.toFixed(1).replace(/\.0$/, "") + "%"
            : "0%";
        const down = formatSize(status.down || 0);
        const up = formatSize(status.up || 0);
        const indexLabel = String(index + 1).padStart(2, "0");
        const prefix = indexLabel + " [" + fullHash + "] ";
        let line = prefix + title;
        const targetColumn = 80;
        if (line.length < targetColumn) {
          line += " ".repeat(targetColumn - line.length);
        } else {
          line += " ";
        }
        line +=
          " — peers=" +
          String(peers) +
          ", " +
          progress +
          ", ↓" +
          down +
          ", ↑" +
          up;
        return line;
      });
      whdaInfohashesEl.textContent = lines.join("\n");
    }

    function refreshLibraryMovieStatus() {
      const listEl = document.getElementById("movie-list");
      if (!listEl) return;
      const sizeNodes = listEl.querySelectorAll(".movie-meta-size");
      sizeNodes.forEach((node) => {
        const baseSize = node.dataset.baseSize || node.textContent || "";
        const hash = (node.dataset.hash || "").toLowerCase();
        if (!hash) {
          node.textContent = baseSize;
          return;
        }

        const li = node.closest(".movie");
        const button = li ? li.querySelector(".movie-download-button") : null;
        if (button) {
          button.classList.remove("is-arming", "is-progress", "is-done");
        }

        const status = whdaStatus[hash];
        if (!status) {
          node.textContent = baseSize ? baseSize + " · have 0%" : "have 0%";
          if (button) {
            if (button.dataset.armed === "1") {
              button.classList.add("is-arming");
              button.textContent = "Searching peers";
            } else {
              button.textContent = button.dataset.baseLabel || "Load";
            }
          }
          return;
        }

        const bytes =
          typeof status.totalBytes === "number" && status.totalBytes > 0
            ? status.totalBytes
            : null;
        const sizeLabel = bytes ? formatSize(bytes) : baseSize || "unknown";
        const rawProgress =
          typeof status.progress === "number" ? status.progress : null;
        const progressLabel =
          rawProgress != null
            ? rawProgress.toFixed(1).replace(/\.0$/, "") + "%"
            : "?%";
        const peers = status.peers != null ? String(status.peers) : "?";

        node.textContent =
          sizeLabel + " · have " + progressLabel + " · peers " + peers;

        if (button) {
          if (rawProgress == null || rawProgress <= 0) {
            if (button.dataset.armed === "1") {
              button.textContent = "Searching peers";
              button.classList.add("is-arming");
            } else {
              button.textContent = button.dataset.baseLabel || "Load";
            }
          } else if (rawProgress >= 99.5) {
            button.textContent = "Done";
            button.classList.add("is-done");
          } else {
            button.textContent = "Downloading";
            button.classList.add("is-progress");
          }
        }
      });
    }

    function createMovieElement(movie, onActivate) {
      const li = document.createElement("li");
      li.className = "movie";
      li.dataset.id = movie.id;
      const hash =
        (movie.hash || movie.infohash || "").trim().toLowerCase();
      if (hash) {
        li.dataset.hash = hash;
      }

      const thumb = document.createElement("div");
      thumb.className = "movie-thumb";
      thumb.textContent = (movie.title || "?")
        .split(" ")
        .map((part) => part[0])
        .join("")
        .slice(0, 3)
        .toUpperCase();

      const main = document.createElement("div");
      main.className = "movie-main";

      const title = document.createElement("div");
      title.className = "movie-title";
      title.textContent = movie.title || movie.id;

      const headerRow = document.createElement("div");
      headerRow.className = "movie-header-row";
      headerRow.appendChild(title);

      let button = null;
      if (typeof onActivate === "function") {
        button = document.createElement("button");
        button.type = "button";
        button.className = "movie-download-button";
        button.textContent = "Load";
        button.dataset.baseLabel = "Load";
        button.dataset.armed = "0";
        if (hash) {
          button.dataset.hash = hash;
        }
        button.addEventListener("click", (event) => {
          event.stopPropagation();
          button.dataset.armed = "1";
          button.classList.add("is-arming");
          button.textContent = "Searching peers";
          onActivate();
        });
        headerRow.appendChild(button);
      }

      const meta = document.createElement("div");
      meta.className = "movie-meta";

      const tagsContainer = document.createElement("div");
      tagsContainer.className = "movie-tags";
      if (Array.isArray(movie.tags)) {
        movie.tags.forEach((tag) => {
          const tagEl = document.createElement("span");
          tagEl.className = "movie-tag";
          const normalized = String(tag || "").toLowerCase();
          tagEl.textContent = normalized === "blender" ? "blnr" : tag;
          tagsContainer.appendChild(tagEl);
        });
      }

      const metaRight = document.createElement("div");
      metaRight.className = "movie-meta-right";

      const size = document.createElement("div");
      size.className = "movie-meta-size";
      const baseSize = formatSize(movie.sizeBytes);
      size.dataset.baseSize = baseSize;
      if (hash) {
        size.dataset.hash = hash;
        size.textContent = baseSize ? baseSize + " · have 0%" : "have 0%";
      } else {
        size.textContent = baseSize;
      }
      metaRight.appendChild(size);

      meta.appendChild(tagsContainer);
      meta.appendChild(metaRight);

      main.appendChild(headerRow);
      main.appendChild(meta);

      li.appendChild(thumb);
      li.appendChild(main);

      if (typeof onActivate === "function") {
        li.addEventListener("click", (event) => {
          const target = event.target;
          if (target && target.closest && target.closest(".movie-download-button")) {
            return;
          }
          if (button) {
            button.dataset.armed = "1";
            button.classList.add("is-arming");
          }
          onActivate();
        });
      }

      return li;
    }

    function setActiveMovieElement(activeId) {
      const nodes = document.querySelectorAll(".movie");
      nodes.forEach((node) => {
        if (node.dataset.id === activeId) {
          node.classList.add("is-active");
        } else {
          node.classList.remove("is-active");
        }
      });
    }

    function updateStatusIdle() {
      document.getElementById("status-label").textContent = "Idle";
      document.getElementById("status-title").textContent = "Nothing queued";
      document.getElementById("status-progress").textContent = "0%";
      document.getElementById("status-peers").textContent = "0";
      document.getElementById("status-speed").textContent = "0 kB/s · 0 kB/s";
      const totalSizeEl = document.getElementById("status-total-size");
      if (totalSizeEl) {
        totalSizeEl.textContent = "unknown";
      }
      document.getElementById("status-extra").textContent = "Library idle; no active swarm";
      const dot = document.getElementById("status-dot");
      dot.style.background = "#5a8f63";
      dot.style.boxShadow = "none";
    }

    function updateStatusLoading(movie) {
      document.getElementById("status-label").textContent = "Connecting";
      document.getElementById("status-title").textContent = movie.title || movie.id;
      document.getElementById("status-progress").textContent = "0%";
      document.getElementById("status-peers").textContent = "0";
      document.getElementById("status-speed").textContent = "0 kB/s · 0 kB/s";
      document.getElementById("status-extra").textContent = "Requesting swarm for collection";
      const dot = document.getElementById("status-dot");
      dot.style.background = "#c29a4a";
      dot.style.boxShadow = "none";
    }

    function updateStatusFromTorrent(torrent) {
      const percent = (torrent.progress * 100) || 0;
      const down = torrent.downloadSpeed || 0;
      const up = torrent.uploadSpeed || 0;
      const totalSizeEl = document.getElementById("status-total-size");

      document.getElementById("status-label").textContent =
        percent >= 99.5 ? "Seed" : "Streaming";
      document.getElementById("status-progress").textContent =
        percent.toFixed(1).replace(/\.0$/, "") + "%";
      document.getElementById("status-peers").textContent = String(
        torrent.numPeers || 0
      );
      document.getElementById("status-speed").textContent =
        formatSize(down) + "/s · " + formatSize(up) + "/s";
      if (totalSizeEl) {
        const bytes = torrent.length || 0;
        totalSizeEl.textContent = bytes > 0 ? formatSize(bytes) : "unknown";
      }
      document.getElementById("status-extra").textContent =
        "Swarm " + (torrent.infoHash || "");
      const dot = document.getElementById("status-dot");
      dot.style.background = "#5a8f63";
      dot.style.boxShadow = "none";
      const key = (torrent.infoHash || "").toLowerCase();
      whdaStatus[key] = {
        label: document.getElementById("status-title").textContent || key,
        peers: torrent.numPeers || 0,
        progress: percent,
        down,
        up,
        totalBytes: torrent.length || 0,
      };
      if (typeof refreshWhdaInfohashes === "function") {
        refreshWhdaInfohashes();
      }
      if (typeof refreshLibraryMovieStatus === "function") {
        refreshLibraryMovieStatus();
      }
    }

    function updateStatusError(message) {
      document.getElementById("status-label").textContent = "Error";
      document.getElementById("status-progress").textContent = "0%";
      document.getElementById("status-peers").textContent = "0";
      document.getElementById("status-speed").textContent = "0 kB/s · 0 kB/s";
      document.getElementById("status-extra").textContent = message || "Playback failed";
      const dot = document.getElementById("status-dot");
      dot.style.background = "#b45b6a";
      dot.style.boxShadow = "none";
    }

    function setScanStatus(text) {
      const el = document.getElementById("metadata-scan-status");
      if (el) {
        el.textContent = text;
      }
    }

    function loadBlenderFilmLibrary(listEl, countEl) {
      if (!window.fetch) {
        setScanStatus("Metadata scan: fetch() not available for Blender films");
        return;
      }

      setScanStatus("Metadata scan: loading Blender films (local JSON)");

      fetch("blender-films.json")
        .then((res) => res.json())
        .then((items) => {
          const rows = Array.isArray(items) ? items : [];
          if (!rows.length) {
            setScanStatus("Metadata scan: no Blender films in blender-films.json");
            filmBag = [];
            refreshWhdaInfohashes();
            listEl.innerHTML = "";
            countEl.textContent = "0 films";
            return;
          }

          filmBag = rows.map((row, index) => ({
            hash: "", // no torrent wired yet
            title: row.title || "Blender film " + String(index + 1).padStart(2, "0")
          }));

          whdaStatus = {};
          refreshWhdaInfohashes();

          listEl.innerHTML = "";
          countEl.textContent = filmBag.length + " films (Blender catalog)";

          filmBag.forEach((item, index) => {
            const movie = {
              id:
                "blender-" +
                String(index + 1)
                  .toString()
                  .padStart(2, "0"),
              title: item.title,
              sizeBytes: 0,
              tags: ["blender"],
            };
            const node = createMovieElement(movie, () => {
              setPlayerMeta(movie.title, "No torrent wired (Blender catalog only)");
              updateStatusError("No torrent wired for Blender films yet");
            });
            listEl.appendChild(node);
          });

          setScanStatus("Metadata scan: Blender films loaded (catalog only)");
        })
        .catch(() => {
          setScanStatus("Metadata scan: error loading blender-films.json");
        });
    }

    function initMiniCinema() {
      const listEl = document.getElementById("movie-list");
      const countEl = document.getElementById("library-count");
      const overlayBadge = document.getElementById("player-overlay-badge");
      const videoEl = document.getElementById("player");

      const presetsEl = document.getElementById("client-presets");
      const nostrStatusEl = document.getElementById("nostr-status");
      const scanStatusEl = document.getElementById("metadata-scan-status");
      const metadataLogEl = document.getElementById("metadata-log");
      const whdaInfohashesEl = document.getElementById("whda-infohashes");
      const nostrWhdaEl = document.getElementById("nostr-whda");
      const nostrWhdaReloadButton = document.getElementById("nostr-whda-reload");
      const nostrWhdaApplyButton = document.getElementById("nostr-whda-apply");
      const nostrWhdaSyncButton = document.getElementById("nostr-whda-sync");
      const nostrWhdaExampleButton = document.getElementById("nostr-whda-example");
      const nostrEventFrameEl = document.getElementById("nostr-event-frame");
      const nostrKeyLabelEl = document.getElementById("nostr-key-label");
      const nostrWhdaRemoteSelectEl = document.getElementById("nostr-whda-remote-select");
      const nostrWhdaDInputEl = document.getElementById("nostr-whda-d");
      const collectionModeEl = document.getElementById("collection-mode");
      const cinemaNostrPanelEl = document.getElementById("cinema-nostr-panel");
      const cinemaNostrToggleEl = document.getElementById("cinema-nostr-toggle");
      const libraryStatusTextEl = document.getElementById("library-status-text");
      const librarySpinnerEl = document.getElementById("library-spinner");
      const nostrRemoteSpinnerEl = document.getElementById("nostr-remote-spinner");

      let client = null;
      let activeTorrent = null;
      let activeInfohash = null;
      let statusInterval = null;
      let localNostrSk = null;
      let mediaResolveTimeout = null;
      let whdaRemoteEvents = [];

      function setLibraryStatus(text, isLoading) {
        if (libraryStatusTextEl) {
          libraryStatusTextEl.textContent = text;
        }
        if (librarySpinnerEl) {
          if (isLoading) {
            librarySpinnerEl.classList.add("is-active");
          } else {
            librarySpinnerEl.classList.remove("is-active");
          }
        }
      }

      function setRemoteNotesLoading(isLoading) {
        if (!nostrRemoteSpinnerEl) return;
        if (isLoading) {
          nostrRemoteSpinnerEl.classList.add("is-active");
        } else {
          nostrRemoteSpinnerEl.classList.remove("is-active");
        }
      }

      function ensureClient() {
        if (!client) {
          if (typeof WebTorrent === "undefined") {
            updateStatusError("WebTorrent not available in this browser");
            return null;
          }
          client = new WebTorrent();
        }
        return client;
      }

      function buildCatalogFromTorrent(torrent) {
        const videoPattern = /\.(mp4|m4v|webm|mkv|avi|mov)$/i;
        const files = torrent.files.filter((f) =>
          videoPattern.test(f.name || f.path || "")
        );
        const hash =
          (torrent && typeof torrent.infoHash === "string" && torrent.infoHash) ||
          COLLECTION_INFOHASH ||
          "";
        return files.map((file, index) => {
          const title = (file.path || file.name || "Untitled").split("/").pop();
          return {
            id: "file-" + String(index + 1).toString().padStart(3, "0"),
            title,
            sizeBytes: file.length || 0,
            tags: ["herzog"],
            filePath: file.path || file.name || "",
            hash,
          };
        });
      }

	      function setScanStatus(text) {
        if (scanStatusEl) {
          scanStatusEl.textContent = text;
        }
      }

      function setNostrStatus(text) {
        if (nostrStatusEl) {
          nostrStatusEl.textContent = text;
        }
      }

      function appendMetadataLog(line) {
        if (!metadataLogEl) return;
        const value = (metadataLogEl.textContent || "").trim();
        metadataLogEl.textContent = value ? value + " · " + line : line;
      }

      function setPlayerMeta(title, fileName) {
        const titleEl = document.getElementById("player-meta-title");
        const fileEl = document.getElementById("player-meta-file");
        if (titleEl) {
          titleEl.textContent = title || "No film selected";
        }
        if (fileEl) {
          fileEl.textContent = fileName || "No media file loaded";
        }
      }

      function setActiveInfohash(hash) {
        const el = document.getElementById("active-infohash");
        if (!el) return;
        const value = (hash || "").trim();
        el.textContent = value
          ? "Infohash: " + value
          : "Infohash: —";
      }

      function ensureLocalNostrKey() {
        try {
          if (!("localStorage" in window)) return null;
        } catch (e) {
          return null;
        }

        let existing = null;
        try {
          existing = window.localStorage.getItem("cinema_nostr_sk");
        } catch (e) {
          existing = null;
        }

        if (existing && /^[0-9a-fA-F]{64}$/.test(existing)) {
          return existing.toLowerCase();
        }

        if (
          !("crypto" in window && window.crypto && window.crypto.getRandomValues)
        ) {
          return null;
        }

        try {
          const bytes = new Uint8Array(32);
          window.crypto.getRandomValues(bytes);
          const hex = Array.from(bytes)
            .map((b) => b.toString(16).padStart(2, "0"))
            .join("");
          window.localStorage.setItem("cinema_nostr_sk", hex);
          return hex;
        } catch (e) {
          return null;
        }
      }

	      function refreshLocalNostrKeyLabel() {
        if (!nostrKeyLabelEl) return;
        if (!localNostrSk) {
          nostrKeyLabelEl.textContent =
            "Local Nostr key: not available (no localStorage/crypto)";
          return;
        }
        nostrKeyLabelEl.textContent =
          "Local Nostr key (POC secret, hex): " + localNostrSk;
      }

      function refreshNostrDraftFromFilmBag() {
        if (!nostrWhdaEl) return;
        if (!Array.isArray(filmBag) || !filmBag.length) {
          nostrWhdaEl.textContent = "// WHDA draft is empty – no films loaded yet";
          refreshWhdaInfohashes();
          return;
        }
        const content = {
          items: filmBag.map((item) => ({
            infohash: item.hash,
            title: item.title,
          })),
        };
        try {
          nostrWhdaEl.textContent = JSON.stringify(content, null, 2);
        } catch (e) {
          nostrWhdaEl.textContent = "// Failed to render WHDA draft";
        }
        refreshWhdaInfohashes();
      }

      function loadBlenderWhdaExampleLibrary(listEl, countEl) {
        const items = Array.isArray(EXAMPLE_WHDA_ITEMS)
          ? EXAMPLE_WHDA_ITEMS
          : [];
        if (!items.length) {
          setScanStatus("Metadata scan: no Blender WHDA example items");
          filmBag = [];
          refreshNostrDraftFromFilmBag();
          if (countEl) {
            countEl.textContent = "0 films";
          }
          if (listEl) {
            listEl.innerHTML = "";
          }
          setLibraryStatus("Library: no Blender WHDA items", false);
          return;
        }

        filmBag = items.map((item) => ({
          hash: item.hash,
          title: item.title,
        }));

        whdaStatus = {};
        refreshNostrDraftFromFilmBag();

        if (listEl && countEl) {
          listEl.innerHTML = "";
          countEl.textContent =
            "Blender cinema bag (" + String(filmBag.length) + " films)";

          filmBag.forEach((item, index) => {
            const movie = {
              id:
                "film-" +
                String(index + 1)
                  .toString()
                  .padStart(2, "0"),
              title: item.title,
              sizeBytes: 0,
              tags: ["blender"],
              hash: item.hash,
            };
            const node = createMovieElement(movie, () => {
              loadFilmFromHash(item.hash, item.title, movie.id);
            });
            listEl.appendChild(node);
          });
        }

        startMetadataScanFromHashes(filmBag);
        setScanStatus("Metadata scan: Blender WHDA example applied locally");
        setLibraryStatus(
          "Library: Blender cinema bag (" + String(filmBag.length) + " films)",
          false
        );
      }

      function loadWhdaDraftFromEvent(event) {
        if (!event || !nostrWhdaEl) return;
        if (nostrWhdaDInputEl && Array.isArray(event.tags)) {
          const dTag =
            (event.tags.find((t) => Array.isArray(t) && t[0] === "d") || [null, ""])[1] ||
            "";
          if (dTag) {
            nostrWhdaDInputEl.value = dTag;
          }
        }
        const raw = typeof event.content === "string" ? event.content : "";
        if (!raw) return;
        try {
          const parsed = JSON.parse(raw);
          nostrWhdaEl.textContent = JSON.stringify(parsed, null, 2);
        } catch (e) {
          nostrWhdaEl.textContent = raw;
        }
      }

      function applyWhdaDraftLocally() {
        if (!nostrWhdaEl) return;
        let raw = nostrWhdaEl.textContent || "";
        raw = raw.trim();
        if (!raw || raw.startsWith("//")) {
          setScanStatus("Metadata scan: WHDA draft is empty");
          return;
        }
        try {
          const payload = JSON.parse(raw);
          const rawItems = Array.isArray(payload.items)
            ? payload.items
            : Array.isArray(payload)
            ? payload
            : [];
          const items = [];
          const seen = new Set();
          rawItems.forEach((item) => {
            if (!item || typeof item.infohash !== "string") return;
            const hash = item.infohash.trim();
            if (!/^[0-9a-fA-F]{40}$/.test(hash)) return;
            const key = hash.toLowerCase();
            if (seen.has(key)) return;
            seen.add(key);
            const title = item.title || hash;
            items.push({ hash, title });
          });

          if (!items.length) {
            setScanStatus("Metadata scan: no valid items in WHDA draft");
            filmBag = [];
            refreshNostrDraftFromFilmBag();
            return;
          }

          listEl.innerHTML = "";
          countEl.textContent = items.length + " films";

          filmBag = items.map((item) => ({
            hash: item.hash,
            title: item.title,
          }));
          whdaStatus = {};
          refreshNostrDraftFromFilmBag();

          filmBag.forEach((item, index) => {
            const movie = {
              id:
                "film-" +
                String(index + 1)
                  .toString()
                  .padStart(2, "0"),
              title: item.title,
              sizeBytes: 0,
              tags: collectionMode === "blender" ? ["blender"] : ["herzog"],
              hash: item.hash,
            };
            const node = createMovieElement(movie, () => {
              loadFilmFromHash(item.hash, item.title, movie.id);
            });
            listEl.appendChild(node);
          });

          startMetadataScanFromHashes(filmBag);
          setScanStatus("Metadata scan: WHDA draft applied locally");
        } catch (e) {
          setScanStatus("Metadata scan: error parsing WHDA draft");
        }
      }

      function buildWhdaItemsFromDraftOrFilmBag() {
        let items = [];
        if (nostrWhdaEl) {
          let raw = (nostrWhdaEl.textContent || "").trim();
          if (raw && !raw.startsWith("//")) {
            try {
              const payload = JSON.parse(raw);
              const rawItems = Array.isArray(payload.items)
                ? payload.items
                : Array.isArray(payload)
                ? payload
                : [];
              const seen = new Set();
              rawItems.forEach((item) => {
                if (!item || typeof item.infohash !== "string") return;
                const hash = item.infohash.trim();
                if (!/^[0-9a-fA-F]{40}$/.test(hash)) return;
                const key = hash.toLowerCase();
                if (seen.has(key)) return;
                seen.add(key);
                const title = item.title || hash;
                items.push({ hash, title });
              });
            } catch (e) {
              // fall back to filmBag
            }
          }
        }

        if (!items.length && Array.isArray(filmBag) && filmBag.length) {
          items = filmBag.slice();
        }

        return items;
      }

      function buildWhdaEventBase() {
        const items = buildWhdaItemsFromDraftOrFilmBag();
        if (!items.length) return null;

        const content = {
          items: items.map((item) => ({
            infohash: item.hash,
            title: item.title,
          })),
        };

        const now = Math.floor(Date.now() / 1000);

        let dTag = NOSTR_WHDA_D;
        if (nostrWhdaDInputEl && typeof nostrWhdaDInputEl.value === "string") {
          const candidate = nostrWhdaDInputEl.value.trim();
          if (candidate) {
            dTag = candidate;
          }
        }

        let pubkey = localNostrSk || "0".repeat(64);
        try {
          if (
            window.NostrTools &&
            typeof window.NostrTools.getPublicKey === "function" &&
            localNostrSk
          ) {
            pubkey = window.NostrTools.getPublicKey(localNostrSk);
          }
        } catch (e) {
          // fall back to placeholder pubkey
        }

        const event = {
          pubkey,
          created_at: now,
          kind: NOSTR_PRESETS_KIND,
          tags: [
            ["d", dTag],
            ["t", "cinema"],
            ["t", "herzog"],
            ["client", "cinema-poc0.2"],
          ],
          content: JSON.stringify(content),
        };

        return event;
      }

      function reloadWhdaDraftFromRelay() {
        if (!NOSTR_RELAY || typeof WebSocket === "undefined") {
          setNostrStatus("Nostr WHDA: relay disabled");
          return;
        }
        if (!nostrWhdaRemoteSelectEl) {
          setNostrStatus("Nostr WHDA: remote select not available");
          return;
        }

        setNostrStatus("Nostr WHDA: loading notes from relay…");
        setRemoteNotesLoading(true);

        whdaRemoteEvents = [];
        nostrWhdaRemoteSelectEl.innerHTML = "";
        const reloadOption = document.createElement("option");
        reloadOption.value = "__reload__";
        reloadOption.textContent = "Load from relay…";
        nostrWhdaRemoteSelectEl.appendChild(reloadOption);
        const loadingOption = document.createElement("option");
        loadingOption.value = "";
        loadingOption.textContent = "Loading…";
        nostrWhdaRemoteSelectEl.appendChild(loadingOption);

        let resolved = false;
        let ws;
        try {
          ws = new WebSocket(NOSTR_RELAY);
        } catch (e) {
          nostrWhdaRemoteSelectEl.innerHTML = "";
          const errOption = document.createElement("option");
          errOption.value = "";
          errOption.textContent = "Error opening relay";
          nostrWhdaRemoteSelectEl.appendChild(errOption);
          setNostrStatus("Nostr WHDA: error opening WebSocket");
          return;
        }

        const done = () => {
          if (resolved) return;
          resolved = true;
          try {
            if (ws && ws.readyState === WebSocket.OPEN) {
              ws.close();
            }
          } catch (e) {
            // ignore
          }

          whdaRemoteEvents.sort((a, b) => {
            const aTs = typeof a.created_at === "number" ? a.created_at : 0;
            const bTs = typeof b.created_at === "number" ? b.created_at : 0;
            return bTs - aTs;
          });
          if (whdaRemoteEvents.length > 10) {
            whdaRemoteEvents = whdaRemoteEvents.slice(0, 10);
          }

          nostrWhdaRemoteSelectEl.innerHTML = "";

          const reloadOption = document.createElement("option");
          reloadOption.value = "__reload__";
          reloadOption.textContent = "Load from relay…";
          nostrWhdaRemoteSelectEl.appendChild(reloadOption);

          if (!whdaRemoteEvents.length) {
            const noneOption = document.createElement("option");
            noneOption.value = "";
            noneOption.textContent = "No cinema notes on relay";
            nostrWhdaRemoteSelectEl.appendChild(noneOption);
            setNostrStatus("Nostr WHDA: no cinema notes on relay");
            setRemoteNotesLoading(false);
            return;
          }

          const placeholder = document.createElement("option");
          placeholder.value = "";
          placeholder.textContent = "Select note by d / id…";
          nostrWhdaRemoteSelectEl.appendChild(placeholder);

          whdaRemoteEvents.forEach((ev, index) => {
            const opt = document.createElement("option");
            opt.value = String(index);
            const tags = Array.isArray(ev.tags) ? ev.tags : [];
            const dTag =
              (tags.find((t) => Array.isArray(t) && t[0] === "d") || [null, ""])[1] ||
              "no-d-tag";
            const id = ev.id || "";
            const ts =
              typeof ev.created_at === "number" && ev.created_at > 0
                ? new Date(ev.created_at * 1000)
                : null;
            const dateLabel = ts ? ts.toISOString().split("T")[0] : "no-date";
            const idLabel = id || "no-id";
            opt.textContent = dTag + " · " + idLabel + " · " + dateLabel;
            opt.title = id || "";
            nostrWhdaRemoteSelectEl.appendChild(opt);
          });

          setNostrStatus(
            "Nostr WHDA: loaded " + String(whdaRemoteEvents.length) + " cinema note(s) from relay"
          );
          setRemoteNotesLoading(false);
        };

        const timer = setTimeout(() => {
          setNostrStatus("Nostr WHDA: relay timeout");
          done();
        }, 3500);

        ws.onopen = () => {
          const filter = {
            kinds: [NOSTR_PRESETS_KIND],
            "#t": ["cinema"],
          };
          ws.send(JSON.stringify(["REQ", "cinema-whda-draft", filter]));
        };

        ws.onmessage = (event) => {
          let msg;
          try {
            msg = JSON.parse(event.data);
          } catch (e) {
            return;
          }
          if (!Array.isArray(msg) || msg.length < 2) return;
          if (msg[0] === "EVENT") {
            const ev = msg[2];
            if (!ev || typeof ev !== "object") return;
            whdaRemoteEvents.push(ev);
          } else if (msg[0] === "EOSE") {
            clearTimeout(timer);
            done();
          }
        };

        ws.onerror = () => {
          clearTimeout(timer);
          setNostrStatus("Nostr WHDA: error talking to relay");
          done();
          setRemoteNotesLoading(false);
        };
      }

      function refreshNostrEventFrame(event) {
        if (!nostrEventFrameEl) return;
        if (!event) {
          nostrEventFrameEl.textContent =
            "// No WHDA items available to build EVENT frame.";
          return;
        }
        try {
          const frame = ["EVENT", event];
          nostrEventFrameEl.textContent = JSON.stringify(frame, null, 2);
        } catch (e) {
          nostrEventFrameEl.textContent = "// Failed to render EVENT frame.";
        }
      }

      function syncWhdaToRelay() {
        const baseEvent = buildWhdaEventBase();
        if (!baseEvent) {
          setNostrStatus("Nostr presets: no WHDA items to sync");
          return;
        }

        if (!NOSTR_RELAY || typeof WebSocket === "undefined") {
          setNostrStatus("Nostr presets: relay disabled (cannot sync)");
          return;
        }

        const hasNostrSigner =
          typeof window !== "undefined" &&
          window.nostr &&
          typeof window.nostr.signEvent === "function";
        const hasNostrTools =
          typeof window !== "undefined" &&
          window.NostrTools &&
          typeof window.NostrTools.getEventHash === "function" &&
          typeof window.NostrTools.signEvent === "function" &&
          !!localNostrSk;

        console.log("[WHDA] Signing check:", {
          hasNostrTools,
          hasNostrSigner,
          hasLocalKey: !!localNostrSk,
          nostrToolsAvailable: !!window.NostrTools
        });

        const sendEvent = (eventToSend, label) => {
          refreshNostrEventFrame(eventToSend);

          let ws;
          try {
            ws = new WebSocket(NOSTR_RELAY);
          } catch (e) {
            setNostrStatus("Nostr presets: error opening WebSocket for sync");
            return;
          }

          setNostrStatus(label);

          ws.onopen = () => {
            try {
              const frame = ["EVENT", eventToSend];
              ws.send(JSON.stringify(frame));
              setNostrStatus(
                "Nostr presets: WHDA EVENT sent (" +
                  (hasNostrSigner ? "signed" : "unsigned POC") +
                  ", relay may reject)"
              );
            } catch (e) {
              setNostrStatus("Nostr presets: error sending WHDA EVENT");
            } finally {
              try {
                ws.close();
              } catch (e) {
                // ignore
              }
            }
          };

          ws.onerror = () => {
            setNostrStatus("Nostr presets: error during WHDA sync");
            try {
              ws.close();
            } catch (e) {
              // ignore
            }
          };
        };

        if (hasNostrTools) {
          setNostrStatus("Nostr presets: signing WHDA via nostr-tools");
          try {
            const id = window.NostrTools.getEventHash(baseEvent);
            const sig = window.NostrTools.signEvent(baseEvent, localNostrSk);
            const signedEvent = Object.assign({}, baseEvent, { id, sig });
            console.log("[WHDA] Signed event:", signedEvent);
            sendEvent(
              signedEvent,
              "Nostr presets: syncing signed WHDA to relay (nostr-tools)"
            );
          } catch (e) {
            console.error("[WHDA] Signing failed:", e);
            setNostrStatus(
              "Nostr presets: nostr-tools signing failed: " + e.message
            );
            const unsignedEvent = Object.assign(
              {
                id: "0".repeat(64),
                sig: "0".repeat(64),
              },
              baseEvent
            );
            sendEvent(
              unsignedEvent,
              "Nostr presets: syncing unsigned WHDA to relay (POC)"
            );
          }
        } else if (hasNostrSigner) {
          setNostrStatus("Nostr presets: signing WHDA via NIP-07");
          try {
            window.nostr
              .signEvent(baseEvent)
              .then((signed) => {
                sendEvent(signed, "Nostr presets: syncing signed WHDA to relay");
              })
              .catch(() => {
                setNostrStatus(
                  "Nostr presets: NIP-07 signing failed, sending unsigned POC"
                );
                const unsignedEvent = Object.assign(
                  {
                    id: "0".repeat(64),
                    sig: "0".repeat(64),
                  },
                  baseEvent
                );
                sendEvent(
                  unsignedEvent,
                  "Nostr presets: syncing unsigned WHDA to relay (POC)"
                );
              });
          } catch (e) {
            setNostrStatus(
              "Nostr presets: NIP-07 exception, sending unsigned POC"
            );
            const unsignedEvent = Object.assign(
              {
                id: "0".repeat(64),
                sig: "0".repeat(64),
              },
              baseEvent
            );
            sendEvent(
              unsignedEvent,
              "Nostr presets: syncing unsigned WHDA to relay (POC)"
            );
          }
        } else {
          const unsignedEvent = Object.assign(
            {
              id: "0".repeat(64),
              sig: "0".repeat(64),
            },
            baseEvent
          );
          sendEvent(
            unsignedEvent,
            "Nostr presets: syncing unsigned WHDA to relay (POC)"
          );
        }
      }

      function attachTorrentForPlayback(torrent, label, infohash) {
        activeTorrent = torrent;
        activeInfohash =
          (infohash && infohash.toLowerCase()) ||
          ((torrent.infoHash || "").toLowerCase());

        const videoPattern = /\.(mp4|m4v|webm|mkv|avi|mov)$/i;
        const file =
          torrent.files.find((f) =>
            videoPattern.test(f.name || f.path || "")
          ) || torrent.files[0];

        if (!file) {
          updateStatusError("No playable video file in torrent");
          setPlayerMeta(label, "No media file loaded (no playable file)");
          return;
        }

        const fileName = (file.path || file.name || "").split("/").pop();
        setPlayerMeta(label, fileName);

        try {
          if (videoEl) {
            try {
              videoEl.pause();
            } catch (e) {
              // ignore
            }
          }
          if (!videoEl) return;
          file.renderTo(videoEl, (err) => {
            if (err) {
              updateStatusError(
                "Render failed: " + (err.message || String(err))
              );
              return;
            }
            overlayBadge.textContent = "";
            videoEl.play().catch((e) => {
              updateStatusError(
                "Playback failed: " +
                  (e && e.message ? e.message : String(e))
              );
            });
          });
        } catch (e) {
          updateStatusError(
            "Render exception: " +
              (e && e.message ? e.message : String(e))
          );
        }

        updateStatusFromTorrent(torrent);
        if (statusInterval) {
          clearInterval(statusInterval);
        }
        statusInterval = setInterval(() => {
          if (!activeTorrent) return;
          updateStatusFromTorrent(activeTorrent);
        }, 1000);

        if (!torrent.__cinemaErrorHandlerAttached) {
          torrent.on("error", (err) => {
            updateStatusError(err.message || "Torrent error");
            setPlayerMeta(
              label,
              "Error: " +
                (err && err.message ? err.message : "torrent error")
            );
          });
          torrent.__cinemaErrorHandlerAttached = true;
        }
      }

      function loadFilmFromHash(infohash, title, movieId) {
        const c = ensureClient();
        if (!c) return;

        const cleanHash = (infohash || "").trim();
        if (!/^[0-9a-fA-F]{40}$/.test(cleanHash)) {
          updateStatusError("Invalid infohash for " + (title || "film"));
          return;
        }

        const normalizedHash = cleanHash.toLowerCase();

        if (activeTorrent && activeInfohash && activeInfohash !== normalizedHash) {
          activeTorrent = null;
          activeInfohash = null;
        }

        if (statusInterval) {
          clearInterval(statusInterval);
          statusInterval = null;
        }

        if (movieId) {
          setActiveMovieElement(movieId);
        } else {
          setActiveMovieElement(null);
        }

        const label = title || cleanHash;
        setActiveInfohash(normalizedHash);
        setPlayerMeta(label, "Resolving media…");
        updateStatusLoading({ title: label, id: normalizedHash });
        // Rely on Transfer Channel + metadata text; avoid overlaying the player

        if (mediaResolveTimeout) {
          clearTimeout(mediaResolveTimeout);
          mediaResolveTimeout = null;
        }
        mediaResolveTimeout = setTimeout(() => {
          const titleEl = document.getElementById("player-meta-title");
          if (
            titleEl &&
            titleEl.textContent &&
            titleEl.textContent === label
          ) {
            setPlayerMeta(
              label,
              "No peers yet (no metadata from trackers)"
            );
          }
        }, 12000);

        const magnet =
          "magnet:?xt=urn:btih:" +
          normalizedHash +
          "&dn=" +
          encodeURIComponent(label) +
          MAGNET_TRACKERS;

        const existing =
          c.get(normalizedHash) || c.get(cleanHash) || null;

        const useTorrent = (torrent) => {
          if (mediaResolveTimeout) {
            clearTimeout(mediaResolveTimeout);
            mediaResolveTimeout = null;
          }
          attachTorrentForPlayback(torrent, label, normalizedHash);
        };

        if (existing) {
          useTorrent(existing);
        } else {
          c.add(magnet, (torrent) => {
            useTorrent(torrent);
          });
        }
      }

      function loadFilmLibraryFromWhda() {
        if (!NOSTR_RELAY || typeof WebSocket === "undefined") {
          setScanStatus("Metadata scan: WHDA relay disabled");
          filmBag = [];
          refreshNostrDraftFromFilmBag();
          setLibraryStatus("Library: WHDA relay disabled", false);
          return;
        }

        setScanStatus("Metadata scan: loading WHDA from relay…");
        setLibraryStatus("Library: loading cinema bag from relay…", true);

        let resolved = false;
        let ws;
        try {
          ws = new WebSocket(NOSTR_RELAY);
        } catch (e) {
          setScanStatus("Metadata scan: error opening WHDA WebSocket");
          filmBag = [];
          refreshNostrDraftFromFilmBag();
          return;
        }

        const items = [];
        const seen = new Set();

        const done = () => {
          if (resolved) return;
          resolved = true;
          try {
            if (ws && ws.readyState === WebSocket.OPEN) {
              ws.close();
            }
          } catch (e) {
            // ignore
          }

          if (!items.length) {
            setScanStatus("Metadata scan: no WHDA items on relay");
            filmBag = [];
            refreshNostrDraftFromFilmBag();
            setLibraryStatus("Library: no cinema bag on relay", false);
            return;
          }

          listEl.innerHTML = "";
          countEl.textContent = items.length + " films";

          filmBag = items.map((item) => ({
            hash: item.hash,
            title: item.title,
          }));
          refreshNostrDraftFromFilmBag();

          filmBag.forEach((item, index) => {
            const movie = {
              id:
                "film-" +
                String(index + 1)
                  .toString()
                  .padStart(2, "0"),
              title: item.title,
              sizeBytes: 0,
              tags: collectionMode === "blender" ? ["blender"] : ["herzog"],
              hash: item.hash,
            };
            const node = createMovieElement(movie, () => {
              loadFilmFromHash(item.hash, item.title, movie.id);
            });
            listEl.appendChild(node);
          });

          startMetadataScanFromHashes(filmBag);
          setLibraryStatus(
            "Library: cinema bag from relay (" + String(filmBag.length) + " films)",
            false
          );
        };

        const timer = setTimeout(() => {
          setScanStatus("Metadata scan: WHDA relay timeout");
          done();
        }, 3500);

        ws.onopen = () => {
          const filter = {
            kinds: [NOSTR_PRESETS_KIND],
            "#d": [NOSTR_WHDA_D],
          };
          ws.send(JSON.stringify(["REQ", "cinema-whda", filter]));
        };

        ws.onmessage = (event) => {
          let msg;
          try {
            msg = JSON.parse(event.data);
          } catch (e) {
            return;
          }

          if (!Array.isArray(msg) || msg.length < 2) return;
          if (msg[0] === "EVENT") {
            const eventObj = msg[2];
            if (!eventObj || typeof eventObj.content !== "string") return;
            try {
              const payload = JSON.parse(eventObj.content);
              const rawItems = Array.isArray(payload.items)
                ? payload.items
                : Array.isArray(payload)
                ? payload
                : [];
              rawItems.forEach((item) => {
                if (!item || typeof item.infohash !== "string") return;
                const hash = item.infohash.trim();
                if (!/^[0-9a-fA-F]{40}$/.test(hash)) return;
                const key = hash.toLowerCase();
                if (seen.has(key)) return;
                seen.add(key);
                const title = item.title || hash;
                items.push({ hash, title });
              });
            } catch (e) {
              // ignore malformed WHDA content
            }
          } else if (msg[0] === "EOSE") {
            clearTimeout(timer);
            setScanStatus("Metadata scan: WHDA loaded from relay");
            done();
          }
        };

        ws.onerror = () => {
          clearTimeout(timer);
          setScanStatus("Metadata scan: error talking to WHDA relay");
          setLibraryStatus("Library: error talking to WHDA relay", false);
          done();
        };
      }

      function startMetadataScanFromHashes(items) {
        if (!Array.isArray(items) || !items.length) {
          setScanStatus("Metadata scan: no items");
          return;
        }

        const c = ensureClient();
        if (!c) {
          setScanStatus("Metadata scan: WebTorrent unavailable");
          return;
        }

        let index = 0;
        const total = items.length;

        function next() {
          if (index >= total) {
            setScanStatus("Metadata scan: complete (" + total + " films)");
            return;
          }

          const item = items[index];
          const hash = (item && item.hash) || "";
          const label = (item && item.title) || hash;

          if (!/^[0-9a-fA-F]{40}$/.test(hash)) {
            index += 1;
            next();
            return;
          }

          const existing = c.get(hash);
          if (existing) {
            appendMetadataLog(
              label + " (" + hash + ") → already active, skipped"
            );
            index += 1;
            next();
            return;
          }

          setScanStatus(
            "Metadata scan: " + String(index + 1) + " / " + String(total)
          );

            const magnet =
            "magnet:?xt=urn:btih:" +
            hash +
            "&dn=" +
            encodeURIComponent(label) +
            MAGNET_TRACKERS;

          c.add(magnet, (torrent) => {
            const files = Array.isArray(torrent.files) ? torrent.files : [];
            const names = files.map((f) => f.path || f.name || "Unnamed");
            appendMetadataLog(label + " (" + hash + ") → " + names.length + " file(s)");
            const key = (torrent.infoHash || "").toLowerCase();
            const percent = (torrent.progress * 100) || 0;
            whdaStatus[key] = {
              label,
              peers: torrent.numPeers || 0,
              progress: percent,
              down: torrent.downloadSpeed || 0,
              up: torrent.uploadSpeed || 0,
              totalBytes: torrent.length || 0,
            };
            refreshWhdaInfohashes();
            if (typeof refreshLibraryMovieStatus === "function") {
              refreshLibraryMovieStatus();
            }
            setScanStatus(
              "Metadata scan: " +
                String(index + 1) +
                " / " +
                String(total) +
                " (files: " +
                String(names.length) +
                ")"
            );
            try {
              // eslint-disable-next-line no-console
              console.log("[WHDA] metadata for", label, names);
            } catch (e) {
              // ignore console issues
            }
            try {
              torrent.destroy();
            } catch (e) {
              // ignore
            }
            index += 1;
            next();
          }).on("error", (err) => {
            setScanStatus(
              "Metadata scan: " +
                String(index + 1) +
                " / " +
                String(total) +
                " (error)"
            );
            try {
              // eslint-disable-next-line no-console
              console.warn("[WHDA] metadata error for", label, err);
            } catch (e) {
              // ignore console issues
            }
            appendMetadataLog(label + " (" + hash + ") → error");
            index += 1;
            next();
          });
        }

        next();
      }

      function findDefaultIndex(catalog) {
        const needle = DEFAULT_FILE_MATCH.toLowerCase();
        for (let i = 0; i < catalog.length; i += 1) {
          if ((catalog[i].title || "").toLowerCase().includes(needle)) {
            return i;
          }
        }
        return -1;
      }

      function renderCatalog(catalog, torrent) {
        listEl.innerHTML = "";
        countEl.textContent = catalog.length + " files";

        const defaultIndex = findDefaultIndex(catalog);

        catalog.forEach((movie, index) => {
          const node = createMovieElement(movie, () => {
            const c = ensureClient();
            if (!c) return;
            const t = activeTorrent || torrent;
            if (!t) {
              updateStatusError("Collection not loaded yet");
              return;
            }

            if (statusInterval) {
              clearInterval(statusInterval);
              statusInterval = null;
            }

            setActiveMovieElement(movie.id);
            updateStatusLoading(movie);

            const file =
              t.files.find(
                (f) =>
                  (f.path || f.name || "") === movie.filePath ||
                  (f.path || f.name || "")
                    .toLowerCase()
                    .includes((movie.title || "").toLowerCase())
              ) || t.files[0];

            if (!file) {
              updateStatusError("No playable file in collection");
              return;
            }

            try {
              if (videoEl) {
                try {
                  videoEl.pause();
                } catch (e) {
                  // ignore
                }
              }
              if (!videoEl) return;
              file.renderTo(videoEl, (err) => {
                if (err) {
                  updateStatusError(
                    "Render failed: " + (err.message || String(err))
                  );
                  return;
                }
                overlayBadge.textContent = "";
                videoEl.play().catch((e) => {
                  updateStatusError(
                    "Playback failed: " +
                      (e && e.message ? e.message : String(e))
                  );
                });
              });
            } catch (e) {
              updateStatusError(
                "Render exception: " +
                  (e && e.message ? e.message : String(e))
              );
            }

            updateStatusFromTorrent(torrent);
            statusInterval = setInterval(() => {
              if (!activeTorrent) return;
              updateStatusFromTorrent(activeTorrent);
            }, 1000);

            torrent.on("error", (err) => {
              updateStatusError(err.message || "Torrent error");
            });
          });

          listEl.appendChild(node);

          if (index === defaultIndex) {
            setActiveMovieElement(movie.id);
          }
        });
      }

      function loadPresets() {
        if (!presetsEl) return;

        const seenPresets = new Set();

        function addPreset(hash, label) {
          const key =
            (hash || "").toLowerCase() + "|" + String(label || "").trim();
          if (seenPresets.has(key)) return;
          seenPresets.add(key);

          const li = document.createElement("li");
          const button = document.createElement("button");
          button.type = "button";
          button.className = "client-preset";
          button.textContent = label || hash;
          button.addEventListener("click", () => {
            loadFilmFromHash(hash, label, null);
          });
          li.appendChild(button);
          presetsEl.appendChild(li);
        }

        function loadFromNostr() {
          if (!NOSTR_RELAY || typeof WebSocket === "undefined") {
            setNostrStatus("Nostr presets: disabled");
            return Promise.resolve(false);
          }

          return new Promise((resolve) => {
            let resolved = false;
            let ws;
            try {
              ws = new WebSocket(NOSTR_RELAY);
            } catch (e) {
              setNostrStatus("Nostr presets: error opening WebSocket");
              resolve(false);
              return;
            }

            setNostrStatus("Nostr presets: connecting to relay");

            const done = (ok) => {
              if (resolved) return;
              resolved = true;
              try {
                if (ws && ws.readyState === WebSocket.OPEN) {
                  ws.close();
                }
              } catch (e) {
                // ignore
              }
              resolve(ok);
            };

            const timer = setTimeout(() => done(false), 3500);

            ws.onopen = () => {
              const filter = {
                kinds: [NOSTR_PRESETS_KIND],
                "#d": [NOSTR_PRESETS_D],
              };
              ws.send(JSON.stringify(["REQ", "cinema-presets", filter]));
            };

            ws.onmessage = (event) => {
              let msg;
              try {
                msg = JSON.parse(event.data);
              } catch (e) {
                return;
              }

              if (!Array.isArray(msg) || msg.length < 2) return;
              if (msg[0] === "EVENT") {
                const eventObj = msg[2];
                if (!eventObj || typeof eventObj.content !== "string") return;
                try {
                  const payload = JSON.parse(eventObj.content);
                  const items = Array.isArray(payload.items)
                    ? payload.items
                    : Array.isArray(payload)
                    ? payload
                    : [];
                  items.forEach((item) => {
                    if (!item || typeof item.infohash !== "string") return;
                    const hash = item.infohash.trim();
                    if (!/^[0-9a-fA-F]{40}$/.test(hash)) return;
                    addPreset(hash, item.title || hash);
                  });
                  clearTimeout(timer);
                  setNostrStatus("Nostr presets: loaded from relay");
                  done(true);
                } catch (e) {
                  // ignore malformed content
                }
              } else if (msg[0] === "EOSE") {
                clearTimeout(timer);
                if (presetsEl.children.length > 0) {
                  setNostrStatus("Nostr presets: loaded from relay");
                  done(true);
                } else {
                  setNostrStatus("Nostr presets: no presets on relay");
                  done(false);
                }
              }
            };

            ws.onerror = () => {
              clearTimeout(timer);
              setNostrStatus("Nostr presets: error talking to relay");
              done(false);
            };
          });
        }

        loadFromNostr();
      }

      updateStatusIdle();
      overlayBadge.textContent = "Select a film…";
      setNostrStatus("Nostr presets: idle");
      setPlayerMeta(null, null);
      localNostrSk = ensureLocalNostrKey();
      refreshLocalNostrKeyLabel();

      if (collectionModeEl) {
        collectionModeEl.value = collectionMode;
        collectionModeEl.addEventListener("change", () => {
          collectionMode =
            collectionModeEl.value === "herzog" ? "herzog" : "blender";
          if (collectionMode === "blender") {
            setLibraryStatus("Library: loading Blender cinema bag…", true);
            loadBlenderWhdaExampleLibrary(listEl, countEl);
          } else {
            setLibraryStatus("Library: loading cinema bag from relay…", true);
            loadFilmLibraryFromWhda();
          }
        });
      }

      if (collectionMode === "blender") {
        setLibraryStatus("Library: loading Blender cinema bag…", true);
        loadBlenderWhdaExampleLibrary(listEl, countEl);
      } else {
        setLibraryStatus("Library: loading cinema bag from relay…", true);
        loadFilmLibraryFromWhda();
      }

      loadPresets();

      if (nostrWhdaReloadButton) {
        nostrWhdaReloadButton.addEventListener("click", () => {
          reloadWhdaDraftFromRelay();
        });
      }

      if (nostrWhdaApplyButton) {
        nostrWhdaApplyButton.addEventListener("click", () => {
          applyWhdaDraftLocally();
        });
      }

      if (nostrWhdaSyncButton) {
        nostrWhdaSyncButton.addEventListener("click", () => {
          syncWhdaToRelay();
        });
      }

      if (nostrWhdaRemoteSelectEl) {
        nostrWhdaRemoteSelectEl.addEventListener("change", () => {
          const value = nostrWhdaRemoteSelectEl.value;
          if (value === "__reload__") {
            reloadWhdaDraftFromRelay();
            return;
          }
          if (!value) return;
          const index = Number(value);
          if (!Number.isFinite(index)) return;
          if (index < 0 || index >= whdaRemoteEvents.length) return;
          loadWhdaDraftFromEvent(whdaRemoteEvents[index]);
        });

        // Prefill remote cinema notes list on load so "blender" / other
        // cinema notes are available without clicking reload.
        reloadWhdaDraftFromRelay();
      }

      if (cinemaNostrPanelEl && cinemaNostrToggleEl) {
        function refreshCinemaNostrToggleLabel() {
          const collapsed = cinemaNostrPanelEl.classList.contains("panel-collapsed");
          cinemaNostrToggleEl.textContent = collapsed ? "Show" : "Hide";
        }

        cinemaNostrToggleEl.addEventListener("click", () => {
          cinemaNostrPanelEl.classList.toggle("panel-collapsed");
          refreshCinemaNostrToggleLabel();
        });

        refreshCinemaNostrToggleLabel();
      }

      if (nostrWhdaExampleButton) {
        nostrWhdaExampleButton.addEventListener("click", () => {
          if (!nostrWhdaEl) return;
          const content = {
            items: EXAMPLE_WHDA_ITEMS.map((item) => ({
              infohash: item.hash,
              title: item.title,
            })),
          };
          try {
            nostrWhdaEl.textContent = JSON.stringify(content, null, 2);
          } catch (e) {
            nostrWhdaEl.textContent = "// Failed to generate example WHDA";
            return;
          }
          setScanStatus("Metadata scan: example WHDA draft generated (apply to use)");
        });
      }
    }

    if (document.readyState === "loading") {
      document.addEventListener("DOMContentLoaded", initMiniCinema);
    } else {
      initMiniCinema();
    }
  </script>
</body>
</html>
