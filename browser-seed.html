<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Mini Cinema · Browser Seeder</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="cinema:mode" content="browser-seeder">
  <style>
    :root {
      color-scheme: dark;
      --bg: #050608;
      --bg-alt: #111219;
      --accent: #e0c680;
      --accent-soft: rgba(224, 198, 128, 0.14);
      --text: #f3f3f5;
      --muted: #a3a3b5;
      --border: #252637;
      --radius: 10px;
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "SF Pro Text",
        "Segoe UI", sans-serif;
      background: var(--bg);
      color: var(--text);
      min-height: 100vh;
      display: flex;
      flex-direction: column;
    }

    .app {
      max-width: 960px;
      margin: 0 auto;
      padding: 16px 16px 24px;
      display: flex;
      flex-direction: column;
      gap: 16px;
    }

    header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 8px;
    }

    .title {
      font-size: 18px;
      font-weight: 600;
      letter-spacing: 0.03em;
      text-transform: uppercase;
      display: inline-flex;
      align-items: center;
      gap: 8px;
    }

    .title-mark {
      width: 16px;
      height: 16px;
      border-radius: 999px;
      background: #e2e2ea;
    }

    .subtitle {
      font-size: 12px;
      color: var(--muted);
    }

    .panel {
      background: var(--bg-alt);
      border-radius: var(--radius);
      border: 1px solid var(--border);
      padding: 12px 12px 14px;
      transition: border-color 0.3s, background 0.3s, box-shadow 0.3s;
      position: relative;
    }

    .panel.active {
      border-color: var(--accent);
      background: var(--accent-soft);
      box-shadow: 0 0 0 2px rgba(224, 198, 128, 0.2);
    }

    .panel-stop-btn {
      position: absolute;
      top: 10px;
      right: 10px;
      padding: 4px 10px;
      border-radius: 999px;
      border: 1px solid rgba(224, 198, 128, 0.4);
      background: var(--bg);
      color: var(--accent);
      font-size: 11px;
      font-weight: 500;
      cursor: pointer;
      display: none;
    }

    .panel.active .panel-stop-btn {
      display: block;
    }

    .panel-stop-btn:hover {
      border-color: var(--accent);
      background: rgba(224, 198, 128, 0.12);
    }

    .panel-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 8px;
      gap: 8px;
    }

    .panel-title {
      font-size: 13px;
      letter-spacing: 0.04em;
      text-transform: uppercase;
      color: var(--muted);
    }

    .badge-soft {
      padding: 2px 6px;
      border-radius: 999px;
      background: rgba(255, 255, 255, 0.03);
      border: 1px solid rgba(255, 255, 255, 0.06);
      font-size: 11px;
      color: var(--muted);
    }

    .layout {
      display: flex;
      flex-direction: column;
      gap: 16px;
      align-items: stretch;
    }

    .field-label {
      font-size: 11px;
      color: var(--muted);
      margin-bottom: 2px;
    }

    .mono {
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas,
        "Liberation Mono", "Courier New", monospace;
      font-size: 11px;
      word-break: break-all;
    }

    .input,
    .textarea {
      width: 100%;
      padding: 6px 8px;
      border-radius: 6px;
      border: 1px solid var(--border);
      background: #090a10;
      color: var(--text);
      font-size: 12px;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas,
        "Liberation Mono", "Courier New", monospace;
    }

    .input::placeholder,
    .textarea::placeholder {
      color: rgba(163, 163, 181, 0.7);
    }

    .textarea {
      resize: vertical;
      min-height: 52px;
    }

    .file-input {
      width: 100%;
      padding: 4px 0;
      font-size: 12px;
      color: var(--text);
    }

    .controls-row {
      margin-top: 8px;
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      align-items: center;
    }

    .button {
      padding: 5px 10px;
      border-radius: 999px;
      border: 1px solid rgba(224, 198, 128, 0.4);
      background: transparent;
      color: var(--accent);
      font-size: 12px;
      cursor: pointer;
    }

    .button:hover {
      border-color: rgba(224, 198, 128, 0.7);
      background: rgba(224, 198, 128, 0.08);
    }

    .button:disabled {
      opacity: 0.6;
      cursor: default;
    }

    .status-grid {
      display: grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      gap: 8px;
    }

    .status-item {
      padding: 8px 10px;
      border-radius: 8px;
      background: rgba(0, 0, 0, 0.4);
      border: 1px solid rgba(255, 255, 255, 0.04);
      min-height: 54px;
      display: flex;
      flex-direction: column;
      justify-content: space-between;
    }

    .status-label {
      font-size: 11px;
      color: var(--muted);
    }

    .status-value {
      font-size: 13px;
      font-variant-numeric: tabular-nums;
      margin-top: 3px;
    }

    .status-value-strong {
      color: var(--accent);
    }

    .log {
      background: #050608;
      border-radius: 8px;
      border: 1px solid var(--border);
      padding: 8px 10px;
      height: 260px;
      overflow: auto;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas,
        "Liberation Mono", "Courier New", monospace;
      font-size: 11px;
      white-space: pre-wrap;
      word-break: break-word;
    }

    footer {
      margin-top: 8px;
      font-size: 11px;
      color: var(--muted);
      display: flex;
      justify-content: space-between;
      gap: 8px;
    }

    footer code {
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas,
        "Liberation Mono", "Courier New", monospace;
    }

    @media (max-width: 780px) {
      .layout {
        grid-template-columns: minmax(0, 1fr);
      }
    }
  </style>
</head>
<body>
  <div class="app">
    <header>
      <div>
        <div class="title">
          <span class="title-mark"></span>
          Browser Seeder
        </div>
        <div class="subtitle">
          WebTorrent in browser, seeding local files via WebRTC on the same trackers as the mini cinema tools.
        </div>
      </div>
      <span class="badge-soft" id="status-label">Idle</span>
    </header>

    <section class="panel">
      <div class="panel-header">
        <div class="panel-title">Seeding status</div>
        <button class="button" id="stop-seed" style="display: none;">Stop</button>
      </div>
      <div style="margin-top: 6px;">
        <div class="field-label">Magnet URI</div>
        <div class="input" style="height:auto; min-height: 32px; padding-top: 6px;" id="magnet-output"></div>
      </div>
      <div style="margin-top: 6px;">
        <div class="field-label">Infohash</div>
        <div class="mono" id="infohash-output">–</div>
      </div>
      <aside class="panel" style="margin-top: 12px; background-color: #050608;">
        <div class="panel-header">
          <div class="panel-title">Swarm status</div>
        </div>
        <div class="status-grid">
          <div class="status-item">
            <div class="status-label">Active method</div>
            <div class="status-value" id="status-method">–</div>
          </div>
          <div class="status-item">
            <div class="status-label">Files</div>
            <div class="status-value status-value-strong" id="status-files">0</div>
          </div>
          <div class="status-item">
            <div class="status-label">Peers</div>
            <div class="status-value" id="status-peers">0</div>
          </div>
          <div class="status-item">
            <div class="status-label">Down / Up</div>
            <div class="status-value" id="status-speed">0 kB/s · 0 kB/s</div>
          </div>
          <div class="status-item">
            <div class="status-label">Uploaded</div>
            <div class="status-value" id="status-uploaded">0 kB</div>
          </div>
        </div>
      </aside>
    </section>

    <main class="layout">
      <div class="panel" id="method-create">
        <button class="panel-stop-btn" onclick="stopSeeding()">⏸ Stop</button>
        <div class="panel-header">
          <div class="panel-title">1. Create Torrent</div>
        </div>
        <div>
          <div class="field-label">Files to seed (creates a new torrent)</div>
          <input
            id="create-torrent-file-input"
            class="file-input"
            type="file"
            multiple
          >
        </div>
        <div style="margin-top: 6px;">
          <div class="field-label">Trackers (one per line, optional)</div>
          <textarea
            id="create-torrent-trackers-input"
            class="textarea"
            rows="3"
            placeholder="Default: WebTorrent WebRTC trackers."
          ></textarea>
        </div>
        <div class="controls-row">
          <button class="button" id="create-torrent-button">Create & Seed</button>
        </div>
      </div>
      <div class="panel" id="method-torrent">
        <button class="panel-stop-btn" onclick="stopSeeding()">⏸ Stop</button>
        <div class="panel-header">
          <div class="panel-title">2. Seed from .torrent file</div>
        </div>
        <div>
          <div class="field-label">.torrent file</div>
          <input
            id="seed-torrent-file-input"
            class="file-input"
            type="file"
            accept=".torrent"
          >
        </div>
        <div style="margin-top: 6px;">
          <div class="field-label">Content files</div>
          <input
            id="seed-torrent-content-input"
            class="file-input"
            type="file"
            multiple
          >
        </div>
        <div class="controls-row">
          <button class="button" id="seed-torrent-button">Seed from .torrent</button>
        </div>
      </div>
      <div class="panel" id="method-seed-magnet">
        <button class="panel-stop-btn" onclick="stopSeeding()">⏸ Stop</button>
        <div class="panel-header">
          <div class="panel-title">3. Seed from magnet/infohash</div>
        </div>
        <div>
          <div class="field-label">Magnet URI or infohash (fetches metadata from swarm)</div>
          <textarea
            id="seed-magnet-uri-input"
            class="textarea"
            rows="1"
            placeholder="magnet:?xt=urn:btih:abc123... or just: abc123..."
          ></textarea>
        </div>
        <div style="margin-top: 6px;">
          <div class="field-label">Content files</div>
          <input
            id="seed-magnet-content-input"
            class="file-input"
            type="file"
            multiple
          >
        </div>
        <div class="controls-row">
          <button class="button" id="seed-magnet-button">Seed from magnet</button>
        </div>
      </div>
      <div class="panel" id="method-download">
        <button class="panel-stop-btn" onclick="stopSeeding()">⏸ Stop</button>
        <div class="panel-header">
          <div class="panel-title">4. Download from magnet</div>
        </div>
        <div>
          <div class="field-label">Magnet URI or infohash (downloads and seeds)</div>
          <textarea
            id="download-magnet-uri-input"
            class="textarea"
            rows="1"
            placeholder="magnet:?xt=urn:btih:abc123... or just: abc123..."
          >460b0b5d942af2de6e3d69333c782f391fcc1ee0</textarea>
        </div>
        <div class="controls-row">
          <button class="button" id="download-magnet-button">Download & Seed</button>
        </div>
      </div>
    </main>

    <section class="panel">
      <div class="panel-header">
        <div class="panel-title">Seeder log</div>
      </div>
      <div class="log" id="log">// Ready. Select a method below to begin.</div>
    </section>

    <footer>
      <span>Use the generated magnet/infohash with <code>debug.html</code> or <code>dplayer.html</code> to test WebRTC-only swarms.</span>
      <span>This seeder is ephemeral: close the tab to stop seeding.</span>
    </footer>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/webtorrent@latest/webtorrent.min.js"></script>
  <script>
    const DEFAULT_TRACKERS = [
      "wss://tracker.openwebtorrent.com",
      "wss://tracker.webtorrent.dev",
      "wss://tracker.btorrent.xyz",
      "wss://tracker.0x6d.net"
    ];

    function formatSize(bytes) {
      if (!Number.isFinite(bytes) || bytes <= 0) return "0 kB";
      const units = ["B", "kB", "MB", "GB", "TB"];
      let value = bytes;
      let unitIndex = 0;
      while (value >= 1024 && unitIndex < units.length - 1) {
        value /= 1024;
        unitIndex += 1;
      }
      return (
        value.toFixed(value >= 100 || unitIndex === 0 ? 0 : 1) +
        " " +
        units[unitIndex]
      );
    }

    function initBrowserSeeder() {
      // Create/seed
      const createTorrentFileInput = document.getElementById("create-torrent-file-input");
      const createTorrentTrackersInput = document.getElementById("create-torrent-trackers-input");
      const createTorrentButton = document.getElementById("create-torrent-button");

      // Seed from .torrent
      const seedTorrentFileInput = document.getElementById("seed-torrent-file-input");
      const seedTorrentContentInput = document.getElementById("seed-torrent-content-input");
      const seedTorrentButton = document.getElementById("seed-torrent-button");

      // Seed from magnet
      const seedMagnetUriInput = document.getElementById("seed-magnet-uri-input");
      const seedMagnetContentInput = document.getElementById("seed-magnet-content-input");
      const seedMagnetButton = document.getElementById("seed-magnet-button");

      // Download from magnet
      const downloadMagnetUriInput = document.getElementById("download-magnet-uri-input");
      const downloadMagnetButton = document.getElementById("download-magnet-button");

      const stopButton = document.getElementById("stop-seed");

      // Status
      const magnetOutput = document.getElementById("magnet-output");
      const infohashOutput = document.getElementById("infohash-output");
      const statusLabelEl = document.getElementById("status-label");
      const statusMethodEl = document.getElementById("status-method");
      const filesEl = document.getElementById("status-files");
      const peersEl = document.getElementById("status-peers");
      const speedEl = document.getElementById("status-speed");
      const uploadedEl = document.getElementById("status-uploaded");
      const logEl = document.getElementById("log");

      let client = null;
      let activeTorrent = null;
      let statusInterval = null;
      let activeMethodPanel = null;

      function setActiveMethod(methodId) {
        // Clear previous active panel
        if (activeMethodPanel) {
          activeMethodPanel.classList.remove('active');
        }
        // Set new active panel
        const panel = document.getElementById(methodId);
        if (panel) {
          panel.classList.add('active');
          activeMethodPanel = panel;
        }
      }

      function clearActiveMethod() {
        if (activeMethodPanel) {
          activeMethodPanel.classList.remove('active');
          activeMethodPanel = null;
        }
      }

      function appendLog(line) {
        if (!logEl) return;
        const existing = (logEl.textContent || "").replace(/^\/\/.*\n?/, "");
        const now = new Date();
        const ts = now.toTimeString().split(" ")[0];
        const next = "[" + ts + "] " + line;
        logEl.textContent = existing ? existing + "\n" + next : next;
        logEl.scrollTop = logEl.scrollHeight;
      }

      function resetStatus() {
        filesEl.textContent = "0";
        peersEl.textContent = "0";
        speedEl.textContent = "0 kB/s · 0 kB/s";
        uploadedEl.textContent = "0 kB";
        infohashOutput.textContent = "–";
        magnetOutput.textContent = "";
        statusLabelEl.textContent = "Idle";
        statusMethodEl.textContent = "–";
        stopButton.style.display = "none";
      }

      function ensureClient() {
        if (client) return client;
        if (typeof WebTorrent === "undefined") {
          appendLog("WebTorrent is not available in this browser.");
          statusLabelEl.textContent = "No WebTorrent";
          return null;
        }
        client = new WebTorrent();
        appendLog("Created WebTorrent client (browser seeder).");
        client.on("error", (err) => {
          appendLog(
            "[client error] " +
              (err && err.message ? err.message : String(err))
          );
        });
        client.on("warning", (err) => {
          appendLog(
            "[client warning] " +
              (err && err.message ? err.message : String(err))
          );
        });
        return client;
      }

      function stopSeeding() {
        if (statusInterval) {
          clearInterval(statusInterval);
          statusInterval = null;
        }
        if (activeTorrent) {
          try {
            appendLog("Stopping " + (activeTorrent.name || "torrent") + "...");
            activeTorrent.destroy();
          } catch (e) {
            // ignore
          }
          activeTorrent = null;
        }
        if (client) {
          try {
            client.destroy();
          } catch (e) {
            // ignore
          }
          client = null;
        }
        clearActiveMethod();
        resetStatus();
      }
      
      function onTorrent(torrent, method) {
        activeTorrent = torrent;
        infohashOutput.textContent = torrent.infoHash || "–";
        magnetOutput.textContent = torrent.magnetURI || "";
        statusMethodEl.textContent = method;
        appendLog(
          "Seeding torrent: " +
            (torrent.name || torrent.infoHash || "unnamed")
        );
        appendLog("Magnet: " + (torrent.magnetURI || ""));
        statusLabelEl.textContent = "Seeding";
        stopButton.style.display = "block";

        if (statusInterval) {
          clearInterval(statusInterval);
        }
        statusInterval = setInterval(() => {
          if (!activeTorrent) return;
          const t = activeTorrent;
          peersEl.textContent = String(t.numPeers || 0);
          const down = t.downloadSpeed || 0;
          const up = t.uploadSpeed || 0;
          speedEl.textContent =
            formatSize(down) + "/s · " + formatSize(up) + "/s";
          uploadedEl.textContent = formatSize(t.uploaded || 0);
        }, 1000);

        torrent.on("wire", (wire, addr) => {
          appendLog("Peer connected: " + (addr || "WebRTC peer"));
        });

        torrent.on("noPeers", (announceType) => {
          appendLog(
            "noPeers from " +
              (announceType || "all sources") +
              " (seeder side)."
          );
        });

        torrent.on("error", (err) => {
          statusLabelEl.textContent = "Error";
          appendLog(
            "Torrent error: " +
              (err && err.message ? err.message : String(err))
          );
        });
      }

      function startSeeding(files, opts, method, expectedInfoHash = null) {
        const c = ensureClient();
        if (!c) return;

        if (!files.length) {
          appendLog("Select at least one file to seed.");
          statusLabelEl.textContent = "Error";
          return;
        }

        resetStatus();
        filesEl.textContent = String(files.length);
        statusLabelEl.textContent = "Connecting";
        appendLog(
          "Starting WebRTC seeding with trackers: " + (opts.announce || []).join(", ")
        );

        try {
          c.seed(files, opts, (torrent) => {
            if (expectedInfoHash && torrent.infoHash !== expectedInfoHash) {
              appendLog(`Error: Infohash mismatch. Expected ${expectedInfoHash}, but got ${torrent.infoHash}. Make sure you selected the correct content files and they match the original torrent structure.`);
              stopSeeding();
              return;
            }
            onTorrent(torrent, method);
          });
        } catch (e) {
          statusLabelEl.textContent = "Error";
          appendLog(
            "Error starting seeding: " +
              (e && e.message ? e.message : String(e))
          );
        }
      }

      function createTorrent() {
        // Auto-stop if already active
        if (activeTorrent) {
          stopSeeding();
        }

        const files = createTorrentFileInput && createTorrentFileInput.files ? Array.from(createTorrentFileInput.files) : [];
        const trackerLines = createTorrentTrackersInput.value
          .split(/\r?\n/)
          .map((line) => line.trim())
          .filter(Boolean);
        const trackers = trackerLines.length ? trackerLines : DEFAULT_TRACKERS.slice();
        startSeeding(files, { announce: trackers }, "Create");
        setActiveMethod('method-create');
      }

      function seedFromTorrentFile() {
        // Auto-stop if already active
        if (activeTorrent) {
          stopSeeding();
        }

        const torrentFile = seedTorrentFileInput.files[0];
        const contentFiles = seedTorrentContentInput && seedTorrentContentInput.files ? Array.from(seedTorrentContentInput.files) : [];

        if (!torrentFile) {
          appendLog("Please select a .torrent file.");
          return;
        }
        if (contentFiles.length === 0) {
          appendLog("Please select the content files to seed.");
          return;
        }

        const c = ensureClient();
        if (!c) return;

        resetStatus();
        statusLabelEl.textContent = "Parsing torrent...";
        appendLog("Parsing .torrent file...");

        const reader = new FileReader();
        reader.onload = function(e) {
          try {
            // Use WebTorrent to parse the .torrent file
            const tempTorrent = c.add(new Uint8Array(e.target.result), { path: '/tmp' });

            tempTorrent.on('metadata', () => {
              const infoHash = tempTorrent.infoHash;
              const trackers = (tempTorrent.announce || []).length ? tempTorrent.announce : DEFAULT_TRACKERS.slice();

              // Extract metadata
              const opts = {
                announce: trackers,
                name: tempTorrent.name,
                pieceLength: tempTorrent.pieceLength
              };

              appendLog("Parsed .torrent: " + tempTorrent.name + " (infohash: " + infoHash + ")");

              // Destroy temp torrent
              tempTorrent.destroy(() => {
                // Now seed with the actual files
                filesEl.textContent = String(contentFiles.length);
                startSeeding(contentFiles, opts, "Torrent file", infoHash);
                setActiveMethod('method-torrent');
              });
            });

            tempTorrent.on('error', (err) => {
              appendLog("Error parsing .torrent: " + err.message);
              statusLabelEl.textContent = "Error";
              try {
                tempTorrent.destroy();
              } catch (e) {
                // ignore
              }
            });
          } catch (err) {
            appendLog("Error reading torrent file: " + err.message);
            statusLabelEl.textContent = "Error";
          }
        };
        reader.readAsArrayBuffer(torrentFile);
      }
      
      function parseMagnetURI(uri) {
        const result = { xt: null, dn: null, tr: [] };
        if (!uri) return result;
        
        if (uri.startsWith('magnet:?')) {
            const parts = uri.split('&');
            parts.forEach(part => {
              if (part.startsWith('magnet:?xt=')) {
                result.xt = part.substring('magnet:?xt='.length);
              } else if (part.startsWith('xt=')) {
                result.xt = part.substring('xt='.length);
              } else if (part.startsWith('dn=')) {
                result.dn = decodeURIComponent(part.substring('dn='.length));
              } else if (part.startsWith('tr=')) {
                result.tr.push(decodeURIComponent(part.substring('tr='.length)));
              }
            });
            if (result.xt && result.xt.startsWith('urn:btih:')) {
                result.xt = result.xt.substring('urn:btih:'.length);
            }
        } else {
            // Assume it's an infohash
            result.xt = uri;
        }
        return result;
      }

      function seedFromMagnetOrInfohash() {
        // Auto-stop if already active
        if (activeTorrent) {
          stopSeeding();
        }

        const magnetInput = seedMagnetUriInput.value.trim();
        const contentFiles = seedMagnetContentInput && seedMagnetContentInput.files ? Array.from(seedMagnetContentInput.files) : [];

        if (!magnetInput) {
          appendLog("Please enter a magnet URI or infohash.");
          return;
        }
        if (contentFiles.length === 0) {
          appendLog("Please select the content files to seed.");
          return;
        }

        const c = ensureClient();
        if (!c) return;

        // Parse magnet or convert infohash to magnet
        let magnetURI;
        if (magnetInput.startsWith('magnet:')) {
          magnetURI = magnetInput;
        } else {
          // Assume it's an infohash - convert to magnet URI
          const infohash = magnetInput.toLowerCase();
          const trackerParams = DEFAULT_TRACKERS.map(t => '&tr=' + encodeURIComponent(t)).join('');
          magnetURI = 'magnet:?xt=urn:btih:' + infohash + trackerParams;
          appendLog("Converted infohash to magnet URI.");
        }

        resetStatus();
        filesEl.textContent = String(contentFiles.length);
        statusLabelEl.textContent = "Fetching metadata";
        appendLog("Fetching torrent metadata from magnet URI...");
        setActiveMethod('method-seed-magnet');

        // First, add the magnet to fetch metadata (without downloading)
        try {
          const tempTorrent = c.add(magnetURI, {
            path: '/tmp/cinema-metadata-fetch',
            skipVerify: true
          });

          tempTorrent.on('metadata', () => {
            appendLog("Metadata received: " + tempTorrent.name);

            // Extract metadata
            const opts = {
              announce: tempTorrent.announce || DEFAULT_TRACKERS.slice(),
              name: tempTorrent.name,
              pieceLength: tempTorrent.pieceLength
            };

            const expectedInfoHash = tempTorrent.infoHash;

            // Destroy the temp torrent
            tempTorrent.destroy(() => {
              appendLog("Starting seeding with extracted metadata...");
              // Now seed with the actual files using the extracted metadata
              startSeeding(contentFiles, opts, "Magnet/Infohash", expectedInfoHash);
            });
          });

          tempTorrent.on('error', (err) => {
            statusLabelEl.textContent = "Error";
            appendLog("Error fetching metadata: " + (err && err.message ? err.message : String(err)));
            try {
              tempTorrent.destroy();
            } catch (e) {
              // ignore
            }
          });

          // Set a timeout for metadata fetch
          setTimeout(() => {
            if (tempTorrent && !tempTorrent.metadata) {
              appendLog("Timeout waiting for metadata. Make sure the magnet/infohash is valid and has seeders.");
              statusLabelEl.textContent = "Timeout";
              try {
                tempTorrent.destroy();
              } catch (e) {
                // ignore
              }
            }
          }, 30000); // 30 second timeout

        } catch (e) {
          statusLabelEl.textContent = "Error";
          appendLog("Error adding magnet: " + (e && e.message ? e.message : String(e)));
        }
      }

      function downloadFromMagnet() {
        // Auto-stop if already active
        if (activeTorrent) {
          stopSeeding();
        }

        const magnetInput = downloadMagnetUriInput.value.trim();

        if (!magnetInput) {
          appendLog("Please enter a magnet URI or infohash.");
          return;
        }

        const c = ensureClient();
        if (!c) return;

        // Parse magnet or convert infohash to magnet
        let magnetURI;
        if (magnetInput.startsWith('magnet:')) {
          magnetURI = magnetInput;
        } else {
          // Assume it's an infohash - convert to magnet URI
          const infohash = magnetInput.toLowerCase();
          const trackerParams = DEFAULT_TRACKERS.map(t => '&tr=' + encodeURIComponent(t)).join('');
          magnetURI = 'magnet:?xt=urn:btih:' + infohash + trackerParams;
          appendLog("Converted infohash to magnet URI.");
        }

        resetStatus();
        statusLabelEl.textContent = "Downloading";
        appendLog("Starting download from magnet URI...");
        setActiveMethod('method-download');

        try {
          const torrent = c.add(magnetURI);

          torrent.on('metadata', () => {
            appendLog("Metadata received: " + torrent.name);
            filesEl.textContent = String(torrent.files.length);
            statusMethodEl.textContent = "Download";
          });

          torrent.on('ready', () => {
            activeTorrent = torrent;
            infohashOutput.textContent = torrent.infoHash || "–";
            magnetOutput.textContent = torrent.magnetURI || "";
            appendLog("Torrent ready. Files: " + torrent.files.map(f => f.name).join(", "));
            statusLabelEl.textContent = "Downloading";
            stopButton.style.display = "block";

            if (statusInterval) {
              clearInterval(statusInterval);
            }
            statusInterval = setInterval(() => {
              if (!activeTorrent) return;
              const t = activeTorrent;
              peersEl.textContent = String(t.numPeers || 0);
              const down = t.downloadSpeed || 0;
              const up = t.uploadSpeed || 0;
              speedEl.textContent =
                formatSize(down) + "/s · " + formatSize(up) + "/s";
              uploadedEl.textContent = formatSize(t.uploaded || 0);

              // Check if download is complete
              if (t.progress === 1) {
                statusLabelEl.textContent = "Seeding";
              }
            }, 1000);
          });

          torrent.on('done', () => {
            appendLog("Download complete! Now seeding...");
            statusLabelEl.textContent = "Seeding";
          });

          torrent.on('wire', (wire, addr) => {
            appendLog("Peer connected: " + (addr || "WebRTC peer"));
          });

          torrent.on('noPeers', (announceType) => {
            appendLog(
              "noPeers from " +
                (announceType || "all sources")
            );
          });

          torrent.on('error', (err) => {
            statusLabelEl.textContent = "Error";
            appendLog(
              "Torrent error: " +
                (err && err.message ? err.message : String(err))
            );
          });

        } catch (e) {
          statusLabelEl.textContent = "Error";
          appendLog("Error adding magnet: " + (e && e.message ? e.message : String(e)));
        }
      }

      createTorrentButton.addEventListener("click", createTorrent);
      seedTorrentButton.addEventListener("click", seedFromTorrentFile);
      seedMagnetButton.addEventListener("click", seedFromMagnetOrInfohash);
      downloadMagnetButton.addEventListener("click", downloadFromMagnet);
      stopButton.addEventListener("click", stopSeeding);

      resetStatus();
      appendLog(
        "Ready. Select a method below to begin."
      );
    }

    if (document.readyState === "loading") {
      document.addEventListener("DOMContentLoaded", initBrowserSeeder);
    } else {
      initBrowserSeeder();
    }
  </script>
</body>
</html>
